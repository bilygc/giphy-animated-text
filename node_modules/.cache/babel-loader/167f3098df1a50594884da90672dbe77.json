{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DEFAULT_ERROR = exports.ERROR_PREFIX = void 0;\n\nvar constants_1 = require(\"./constants\");\n\nvar fetch_error_1 = __importDefault(require(\"./fetch-error\"));\n\nexports.ERROR_PREFIX = \"@giphy/js-fetch-api: \";\nexports.DEFAULT_ERROR = 'Error fetching';\n\nvar identity = function (i) {\n  return i;\n};\n\nvar requestMap = {};\nvar maxLife = 60000; // clear memory cache every minute\n\nvar errorMaxLife = 6000; // clear error memory cache after a second\n\nvar purgeCache = function () {\n  var now = Date.now();\n  Object.keys(requestMap).forEach(function (key) {\n    var ttl = requestMap[key].isError ? errorMaxLife : maxLife;\n\n    if (now - requestMap[key].ts >= ttl) {\n      delete requestMap[key];\n    }\n  });\n};\n\nfunction request(url, normalizer, noCache) {\n  var _this = this;\n\n  if (normalizer === void 0) {\n    normalizer = identity;\n  }\n\n  if (noCache === void 0) {\n    noCache = false;\n  }\n\n  purgeCache();\n\n  if (!requestMap[url] || noCache) {\n    var makeRequest = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var fetchError, response, result, message, result, _1, unexpectedError_1;\n\n        var _a;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              _b.trys.push([0, 9,, 10]);\n\n              return [4\n              /*yield*/\n              , fetch(\"\" + constants_1.serverUrl + url, {\n                method: 'get'\n              })];\n\n            case 1:\n              response = _b.sent();\n              if (!response.ok) return [3\n              /*break*/\n              , 3];\n              return [4\n              /*yield*/\n              , response.json()];\n\n            case 2:\n              result = _b.sent(); // no response id is an indiication of a synthetic response\n\n              if (!((_a = result.meta) === null || _a === void 0 ? void 0 : _a.response_id)) {\n                throw {\n                  message: \"synthetic response\"\n                };\n              } else {\n                // if everything is successful, we return here, otherwise an error will be thrown\n                return [2\n                /*return*/\n                , normalizer(result)];\n              }\n\n              return [3\n              /*break*/\n              , 8];\n\n            case 3:\n              message = exports.DEFAULT_ERROR;\n              _b.label = 4;\n\n            case 4:\n              _b.trys.push([4, 6,, 7]);\n\n              return [4\n              /*yield*/\n              , response.json()];\n\n            case 5:\n              result = _b.sent();\n              if (result.message) message = result.message;\n              return [3\n              /*break*/\n              , 7];\n\n            case 6:\n              _1 = _b.sent();\n              return [3\n              /*break*/\n              , 7];\n\n            case 7:\n              if (requestMap[url]) {\n                // we got a specific error,\n                // normally, you'd want to not fetch this again,\n                // but the api goes down and sends 400s, so allow a refetch after errorMaxLife\n                requestMap[url].isError = true;\n              } // we got an error response, throw with the message in the response body json\n\n\n              fetchError = new fetch_error_1.default(\"\" + exports.ERROR_PREFIX + message, response.status, response.statusText);\n              _b.label = 8;\n\n            case 8:\n              return [3\n              /*break*/\n              , 10];\n\n            case 9:\n              unexpectedError_1 = _b.sent();\n              fetchError = new fetch_error_1.default(unexpectedError_1.message); // if the request fails with an unspecfied error,\n              // the user can request again after the error timeout\n\n              if (requestMap[url]) {\n                requestMap[url].isError = true;\n              }\n\n              return [3\n              /*break*/\n              , 10];\n\n            case 10:\n              throw fetchError;\n          }\n        });\n      });\n    };\n\n    requestMap[url] = {\n      request: makeRequest(),\n      ts: Date.now()\n    };\n  }\n\n  return requestMap[url].request;\n}\n\nexports.default = request;","map":{"version":3,"sources":["../src/request.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DEFAULT_ERROR = exports.ERROR_PREFIX = void 0;\nvar constants_1 = require(\"./constants\");\nvar fetch_error_1 = __importDefault(require(\"./fetch-error\"));\nexports.ERROR_PREFIX = \"@giphy/js-fetch-api: \";\nexports.DEFAULT_ERROR = 'Error fetching';\nvar identity = function (i) { return i; };\nvar requestMap = {};\nvar maxLife = 60000; // clear memory cache every minute\nvar errorMaxLife = 6000; // clear error memory cache after a second\nvar purgeCache = function () {\n    var now = Date.now();\n    Object.keys(requestMap).forEach(function (key) {\n        var ttl = requestMap[key].isError ? errorMaxLife : maxLife;\n        if (now - requestMap[key].ts >= ttl) {\n            delete requestMap[key];\n        }\n    });\n};\nfunction request(url, normalizer, noCache) {\n    var _this = this;\n    if (normalizer === void 0) { normalizer = identity; }\n    if (noCache === void 0) { noCache = false; }\n    purgeCache();\n    if (!requestMap[url] || noCache) {\n        var makeRequest = function () { return __awaiter(_this, void 0, void 0, function () {\n            var fetchError, response, result, message, result, _1, unexpectedError_1;\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _b.trys.push([0, 9, , 10]);\n                        return [4 /*yield*/, fetch(\"\" + constants_1.serverUrl + url, {\n                                method: 'get',\n                            })];\n                    case 1:\n                        response = _b.sent();\n                        if (!response.ok) return [3 /*break*/, 3];\n                        return [4 /*yield*/, response.json()];\n                    case 2:\n                        result = (_b.sent());\n                        // no response id is an indiication of a synthetic response\n                        if (!((_a = result.meta) === null || _a === void 0 ? void 0 : _a.response_id)) {\n                            throw { message: \"synthetic response\" };\n                        }\n                        else {\n                            // if everything is successful, we return here, otherwise an error will be thrown\n                            return [2 /*return*/, normalizer(result)];\n                        }\n                        return [3 /*break*/, 8];\n                    case 3:\n                        message = exports.DEFAULT_ERROR;\n                        _b.label = 4;\n                    case 4:\n                        _b.trys.push([4, 6, , 7]);\n                        return [4 /*yield*/, response.json()];\n                    case 5:\n                        result = (_b.sent());\n                        if (result.message)\n                            message = result.message;\n                        return [3 /*break*/, 7];\n                    case 6:\n                        _1 = _b.sent();\n                        return [3 /*break*/, 7];\n                    case 7:\n                        if (requestMap[url]) {\n                            // we got a specific error,\n                            // normally, you'd want to not fetch this again,\n                            // but the api goes down and sends 400s, so allow a refetch after errorMaxLife\n                            requestMap[url].isError = true;\n                        }\n                        // we got an error response, throw with the message in the response body json\n                        fetchError = new fetch_error_1.default(\"\" + exports.ERROR_PREFIX + message, response.status, response.statusText);\n                        _b.label = 8;\n                    case 8: return [3 /*break*/, 10];\n                    case 9:\n                        unexpectedError_1 = _b.sent();\n                        fetchError = new fetch_error_1.default(unexpectedError_1.message);\n                        // if the request fails with an unspecfied error,\n                        // the user can request again after the error timeout\n                        if (requestMap[url]) {\n                            requestMap[url].isError = true;\n                        }\n                        return [3 /*break*/, 10];\n                    case 10: throw fetchError;\n                }\n            });\n        }); };\n        requestMap[url] = { request: makeRequest(), ts: Date.now() };\n    }\n    return requestMap[url].request;\n}\nexports.default = request;\n//# sourceMappingURL=request.js.map"]},"metadata":{},"sourceType":"script"}